
## 복잡도(Complexity)


복잡도는 알고리즘의 성능을 나타내는 척도. 시간 복잡도와 공간 복잡도로 나눌 수 있다. 

**시간 복잡도**는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미한다. (알고리즘을 위해 필요한 연산의 횟수)

**공간 복잡도**는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미한다. (알고리즘을 위해 필요한 메모리의 양)


### 시간 복잡도

빅오(Big-O) 표기법 사용. 가장 빠르게 증가하는 항만 고려하는 표기법.

```python
a = 5
b = 7
print(a + b)
```
시간 복잡도 : $$O(1)$$

```python
array = [3, 5, 1, 2, 4]  # 5개의 데이터(N=5)

for i in array:
	for j in array:
		temp = i * j
		print(temp)
```
시간 복잡도 : $$O(N^2)$$

| 빅오 표기법 | 명칭 |
| :--: | :--: |
| $$O(1)$$ | 상수 시간 (Constant time) |
| $$O(logN)$$ | 로그 시간 (Log time) |
| $$O(N)$$ | 선형 시간 |
| $$O(NlogN)$$ | 로그 선형 시간 |
| $$O(N^2)$$ | 이차 시간 |
| $$O(N^3)$$ | 삼차 시간 |
| $$O(2^n)$$ | 지수 시간 |
시간 복잡도 표 / 위쪽에 있을수록 더 빠르다.

>일반적으로 O(N^3)을 넘어가면 문제 풀이에서 사용하기 어렵다. CPU 기반의 개인 컴퓨터나 채점용 컴퓨터에서는 연산횟수가 10억을 넘어가면 C 언어를 기준으로 통상 1초 이상의 시간이 소요된다. 이때 N의 크기가 5,000을 넘는다면 족히 10초 이상의 시간이 걸릴 수 있다. 특히 파이썬은 더욱 오래걸리므로 주의가 필요하다.

- N의 범위가 500인 경우 : 시간복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있음
- N의 범위가 2,000인 경우 : 시간복잡도가 O(N^2)인 알고리즘을 설계하면 문제를 풀 수 있음
- N의 범위가 100,000인 경우 : 시간복잡도가 O(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있음
- N의 범위가 10,000,000인 경우 : 시간복잡도가 O(N)인 알고리즘을 설계하면 문제를 풀 수 있음

### 공간 복잡도

시간 복잡도와 동일하게 빅오(Big-O) 표기법 사용.

- int a\[1000] : 4KB
- int a\[1000000] : 4MB
- int a\[2000]\[2000] : 16MB

코딩 테스트는 보통 메모리 사용량을 128~512MB 정도로 제한하기 때문에 일반적인 경우 데이터의 개수가 1,000만 단위가 넘지 않도록 알고리즘을 설계해야 함.


### 시간과 메모리 측정

```python
form random import randint
import time

# 배열에 10,000개의 정수를 삽입
array = []
for _ in range(10000):
	array.append(randint(1, 100))  # 1부터 100 사이의 랜덤한 정수

# 선택 정렬 프로그램 성능 측정
start_time = time.time()

# 선택 정렬 프로그램 소스코드
for i in range(len(array)):
	min_idex = i  # 가장 작은 원소의 인덱스
	for j in range(i+1, len(array)):
		if array[min_idex] > array[j]:
			min_idex = j
	array[i], array[min_idex] = array[min_idex], array[i]  # 스와프

end_time = time.time()  # 측정 종료
print("선택 정렬 성능 측정 :", end_time - start_time)  # 수행 시간 출력

# 배열을 다시 무작위 데이터로 초기화
array = []
for _ in range(10000):
	array.append(randint(1, 100))  # 1부터 100 사이의 랜덤한 정수

# 기본 정렬 라이브러리 성능 측정
start_time = time.time()

# 기본 정렬 라이브러리 사용
array.sort()

end_tiem = time.time()  # 측정 종료
print("기본 정렬 라이브러리 성능 측정 :", end_time - start_time)  # 수행 시간 출력
```

```
선택 정렬 성능 측정 : 35.841460943222046
기본 정렬 라이브러리 성능 측정 : 0.0013387203216552734
```
